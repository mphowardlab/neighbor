// Copyright (c) 2018-2019, Michael P. Howard.
// This file is released under the Modified BSD License.

// Maintainer: mphoward

#ifndef NEIGHBOR_LBVH_TRAVERSER_H_
#define NEIGHBOR_LBVH_TRAVERSER_H_

#include <cuda_runtime.h>

#include "Memory.h"
#include "Tunable.h"


#include "LBVH.h"
#include "TransformOps.h"
#include "TranslateOps.h"

#include "LBVHTraverserData.h"
#include "kernels/LBVHTraverser.cuh"

namespace neighbor
{

//! Linear bounding volume hierarchy traverser using stackless rope scheme.
/*!
 * A LBVHTraverser implements a scheme to traverse a LBVH. For example, two options
 * are using a stack-based traversal or using a stackless rope traversal scheme.
 * A LBVHTraverser will typically take the data from the LBVH and compress it into a
 * format that is efficient for traversal. During this step, the LBVHTraverser is also
 * permitted to modify the LBVH before compression, if it is useful for traversal (e.g.,
 * performing subtree collapse).
 *
 * In this implementation, The LBVH is traversed using a stackless scheme based on skip ropes. The
 * general idea is to store (for each node) the left child (to descend if an
 * overlap occurs) and a skip "rope" to the next node that should be processed
 * (if there is no overlap). The skip rope may point to the LBVHSentinel, which
 * indicates that traversal should be terminated.
 *
 * In order to efficiently perform this traversal, the LBVH data is heavily compressed
 * by the traverser. Each node is represented by an int4 (16B). This is much smaller than
 * the original LBVH data (~56B), and is achieved by compressing the bounding boxes into
 * a low-precision (10-bit) form. The LBVH root node is discretized into 2^10 bins. The
 * remaining bounding boxes are snapped onto this grid in a way that ensures correctness
 * (lower bounds are always rounded down, while upper bounds are always rounded up). The
 * (x,y,z) components are concatenated into one integer (4B) versus the original float3 (12B).
 * The nodes are decompressed into floats during traversal, again in a conservative way to
 * ensure the original node is always enclosed by the compressed/decompressed node. Some
 * additional overlaps can be generated by intersecting these nodes, but this is usually
 * a small number for typical simulations.
 *
 * The query volumes are flexibly defined by a templated \a QueryOpT. Similarly, the output
 * is flexibly implemented using an \a OutputOpT. Common query ops use box or sphere volumes,
 * while output ops may count neighbors or write a neighbor list.
 *
 * The LBVH is not aware of periodic boundary conditions of a scene. The LBVHTraverser accepts
 * an translation operator, which can move the same volume around the scene. By default, only
 * the self-image is traversed.
 */
class LBVHTraverser : public Tunable<unsigned int>
    {
    public:
        //! Constructor.
        LBVHTraverser();

        //! Setup LBVH for traversal in a stream with tunable parameter and a primitive transform operation.
        template<class TransformOpT>
        void setup(const LaunchParameters& params, const LBVH& lbvh, const TransformOpT& transform);

        //! Setup LBVH for traversal in a stream with tunable parameter.
        /*!
         * \param params Launch parameters for kernel execution, including tunable block size and stream.
         * \param lbvh LBVH to traverse.
         */
        void setup(const LaunchParameters& params, const LBVH& lbvh)
            {
            setup(params, lbvh, NullTransformOp());
            }

        //! Setup LBVH for traversal in a stream with a primitive transform operation.
        /*!
         * \param stream CUDA stream for kernel execution.
         * \param lbvh LBVH to traverse.
         * \param transform Transformation operation for cached primitive indexes.
         *
         * \tparam TransformOpT The type of transformation operation.
         *
         * The default block size is 32 threads.
         */
        template<class TransformOpT>
        void setup(cudaStream_t stream, const LBVH& lbvh, const TransformOpT& transform)
            {
            setup(LaunchParameters(32,stream), lbvh, transform);
            }

        //! Setup LBVH for traversal in a stream.
        /*!
         * \param params Launch parameters for kernel execution, including tunable block size and stream.
         * \param lbvh LBVH to traverse.
         *
         * The default block size is 32 threads.
         */
        void setup(cudaStream_t stream, const LBVH& lbvh)
            {
            setup(stream, lbvh, NullTransformOp());
            }

        //! Setup LBVH for traversal in the default stream with a primitive transform operation.
        /*!
         * \param lbvh LBVH to traverse.
         * \param transform Transformation operation for cached primitive indexes.
         *
         * \tparam TransformOpT The type of transformation operation.
         *
         * The default block size is 32 threads, and the kernel executes in the default stream.
         */
        template<class TransformOpT>
        void setup(const LBVH& lbvh, const TransformOpT& transform)
            {
            setup(0, lbvh, transform);
            }

        //! Setup LBVH for traversal in the default stream.
        /*!
         * \param lbvh LBVH to traverse.
         *
         * The default block size is 32 threads, and the kernel executes in the default stream.
         */
        void setup(const LBVH& lbvh)
            {
            setup(0, lbvh, NullTransformOp());
            }

        //! Reset (nullify) the setup
        void reset()
            {
            m_replay = false;
            }

        //! Traverse the LBVH in a stream with tunable parameter, translation, and a primitive transform operation.
        template<class QueryOpT, class OutputOpT, class TranslateOpT, class TransformOpT>
        void traverse(const LaunchParameters& params,
                      const LBVH& lbvh,
                      const QueryOpT& query,
                      const OutputOpT& out,
                      const TranslateOpT& images,
                      const TransformOpT& transform);

        //! Traverse the LBVH in a stream with tunable parameter and translation.
        /*!
         * \param params Launch parameters for kernel execution, including tunable block size and stream.
         * \param lbvh LBVH to traverse.
         * \param query Query operation for defining search volumes and overlaps.
         * \param out Output operation for intersected primitives.
         * \param images Translation operation for moving search volume around.
         *
         * \tparam QueryOpT The type of query operation.
         * \tparam OutputOpT The type of output operation.
         * \tparam TranslateOpT The type of translation operation.
         */
        template<class QueryOpT, class OutputOpT, class TranslateOpT>
        void traverse(const LaunchParameters& params,
                      const LBVH& lbvh,
                      const QueryOpT& query,
                      const OutputOpT& out,
                      const TranslateOpT& images)
            {
            traverse(params, lbvh, query, out, images, NullTransformOp());
            }

        //! Traverse the LBVH in a stream with tunable parameter.
        /*!
         * \param params Launch parameters for kernel execution, including tunable block size and stream.
         * \param lbvh LBVH to traverse.
         * \param query Query operation for defining search volumes and overlaps.
         * \param out Output operation for intersected primitives.
         *
         * \tparam QueryOpT The type of query operation.
         * \tparam OutputOpT The type of output operation.
         *
         * Only the self image (no translation) is traversed.
         */
        template<class QueryOpT, class OutputOpT>
        void traverse(const LaunchParameters& params,
                      const LBVH& lbvh,
                      const QueryOpT& query,
                      const OutputOpT& out)
            {
            traverse(params, lbvh, query, out, SelfOp(), NullTransformOp());
            }

        //! Traverse the LBVH in a stream with translation and a primitive transform operation.
        /*!
         * \param stream CUDA stream for kernel execution.
         * \param lbvh LBVH to traverse.
         * \param query Query operation for defining search volumes and overlaps.
         * \param out Output operation for intersected primitives.
         * \param images Translation operation for moving search volume around.
         * \param transform Transformation operation for cached primitive indexes.
         *
         * \tparam QueryOpT The type of query operation.
         * \tparam OutputOpT The type of output operation.
         * \tparam TranslateOpT The type of translation operation.
         * \tparam TransformOpT The type of transformation operation.
         *
         * The default block size is 32 threads.
         */
        template<class QueryOpT, class OutputOpT, class TranslateOpT, class TransformOpT>
        void traverse(cudaStream_t stream,
                      const LBVH& lbvh,
                      const QueryOpT& query,
                      const OutputOpT& out,
                      const TranslateOpT& images,
                      const TransformOpT& transform)
            {
            traverse(LaunchParameters(32,stream), lbvh, query, out, images, transform);
            }

        //! Traverse the LBVH in a stream with translation.
        /*!
         * \param stream CUDA stream for kernel execution.
         * \param lbvh LBVH to traverse.
         * \param query Query operation for defining search volumes and overlaps.
         * \param out Output operation for intersected primitives.
         * \param images Translation operation for moving search volume around.
         *
         * \tparam QueryOpT The type of query operation.
         * \tparam OutputOpT The type of output operation.
         * \tparam TranslateOpT The type of translation operation.
         *
         * The default block size is 32 threads.
         */
        template<class QueryOpT, class OutputOpT, class TranslateOpT>
        void traverse(cudaStream_t stream,
                      const LBVH& lbvh,
                      const QueryOpT& query,
                      const OutputOpT& out,
                      const TranslateOpT& images)
            {
            traverse(stream, lbvh, query, out, images, NullTransformOp());
            }

        //! Traverse the LBVH in a stream.
        /*!
         * \param stream CUDA stream for kernel execution.
         * \param lbvh LBVH to traverse.
         * \param query Query operation for defining search volumes and overlaps.
         * \param out Output operation for intersected primitives.
         *
         * \tparam QueryOpT The type of query operation.
         * \tparam OutputOpT The type of output operation.
         *
         * The default block size is 32 threads.
         */
        template<class QueryOpT, class OutputOpT>
        void traverse(cudaStream_t stream,
                      const LBVH& lbvh,
                      const QueryOpT& query,
                      const OutputOpT& out)
            {
            traverse(stream, lbvh, query, out, SelfOp(), NullTransformOp());
            }

        //! Traverse the LBVH in the default stream with translation and a primitive transform operation.
        /*!
         * \param lbvh LBVH to traverse.
         * \param query Query operation for defining search volumes and overlaps.
         * \param out Output operation for intersected primitives.
         * \param images Translation operation for moving search volume around.
         * \param transform Transformation operation for cached primitive indexes.
         *
         * \tparam QueryOpT The type of query operation.
         * \tparam OutputOpT The type of output operation.
         * \tparam TranslateOpT The type of translation operation.
         * \tparam TransformOpT The type of transformation operation.
         *
         * The default block size is 32 threads, and the kernel executes in the default stream.
         */
        template<class QueryOpT, class OutputOpT, class TranslateOpT, class TransformOpT>
        void traverse(const LBVH& lbvh,
                      const QueryOpT& query,
                      const OutputOpT& out,
                      const TranslateOpT& images,
                      const TransformOpT& transform)
            {
            traverse(0, lbvh, query, out, images, transform);
            }

        //! Traverse the LBVH in the default stream with translation.
        /*!
         * \param lbvh LBVH to traverse.
         * \param query Query operation for defining search volumes and overlaps.
         * \param out Output operation for intersected primitives.
         * \param images Translation operation for moving search volume around.
         *
         * \tparam QueryOpT The type of query operation.
         * \tparam OutputOpT The type of output operation.
         * \tparam TranslateOpT The type of translation operation.
         *
         * The default block size is 32 threads, and the kernel executes in the default stream.
         */
        template<class QueryOpT, class OutputOpT, class TranslateOpT>
        void traverse(const LBVH& lbvh, const QueryOpT& query, const OutputOpT& out, const TranslateOpT& images)
            {
            traverse(0, lbvh, query, out, images, NullTransformOp());
            }

        //! Traverse the LBVH in the default stream.
        /*!
         * \param lbvh LBVH to traverse.
         * \param query Query operation for defining search volumes and overlaps.
         * \param out Output operation for intersected primitives.
         *
         * \tparam QueryOpT The type of query operation.
         * \tparam OutputOpT The type of output operation.
         *
         * The default block size is 32 threads, and the kernel executes in the default stream.
         */
        template<class QueryOpT, class OutputOpT>
        void traverse(const LBVH& lbvh, const QueryOpT& query, const OutputOpT& out)
            {
            traverse(0, lbvh, query, out, SelfOp(), NullTransformOp());
            }

        //! Access the compressed LBVH data for traversal.
        const shared_array<int4>& getData() const
            {
            return m_data;
            }

    private:
        int m_root;                     //!< Root node
        shared_array<int4> m_data;      //!< Internal representation of the LBVH for traversal
        shared_array<float3> m_lbvh_lo; //!< Lower bound of tree
        shared_array<float3> m_lbvh_hi; //!< Upper bound of tree
        shared_array<float3> m_bins;    //!< Bin size for compression

        //! Compresses the lbvh into internal representation.
        template<class TransformOpT>
        void compress(const LaunchParameters& params, const LBVH& lbvh, const TransformOpT& transform);

        bool m_replay;  //!< If true, the compressed structure has already been set explicitly

        //! Get the pointer version of the data in the traverser.
        const LBVHCompressedData data()
            {
            LBVHCompressedData clbvh;
            clbvh.root = m_root;
            clbvh.data = m_data.get();
            clbvh.lo = m_lbvh_lo.get();
            clbvh.hi = m_lbvh_hi.get();
            clbvh.bins = m_bins.get();
            return clbvh;
            }
    };

LBVHTraverser::LBVHTraverser()
    : Tunable<unsigned int>(32, 1024, 32),
      m_lbvh_lo(1), m_lbvh_hi(1), m_bins(1), m_replay(false)
    {
    }

/*!
 * \param params Launch parameters for kernel execution, including tunable block size and stream.
 * \param lbvh LBVH to traverse.
 * \param transform Transformation operation for cached primitive indexes.
 *
 * \tparam TransformOpT The type of transformation operation.
 *
 * This method just calls the compress method on the LBVH, and marks that this has been done
 * internally so that subsequent calls to traverse do not compress. This is useful if the same
 * LBVH is going to be traversed multiple times. It is the caller's responsibility to ensure
 * that the transform op and lbvh do not change between setup and traversal, or the result will
 * be incorrect.
 *
 * To clear a setup, call reset().
 */
template<class TransformOpT>
void LBVHTraverser::setup(const LaunchParameters& params, const LBVH& lbvh, const TransformOpT& transform)
    {
    if (lbvh.getN() == 0) return;

    compress(params, lbvh, transform);
    m_replay = true;
    }

/*!
 * \param params Launch parameters for kernel execution, including tunable block size and stream.
 * \param lbvh LBVH to traverse.
 * \param query Query operation for defining search volumes and overlaps.
 * \param out Output operation for intersected primitives.
 * \param images Translation operation for moving search volume around.
 * \param transform Transformation operation for cached primitive indexes.
 *
 * \tparam QueryOpT The type of query operation.
 * \tparam OutputOpT The type of output operation.
 * \tparam TranslateOpT The type of translation operation.
 * \tparam TransformOpT The type of transformation operation.
 *
 * A maximum of 32 \a images are allowed due to the internal representation of the image list
 * in the traversal CUDA kernel. This is more than enough to perform traversal in 3D periodic
 * boundary conditions (27 images). Multiple calls to ::traverse are required if
 * more images are needed, but \a out must be compatible with multiple calls.
 *
 * If a query volume overlaps an internal node, the traversal should descend to the left child.
 * If the query volume does not overlap OR it has reached a leaf node, the traversal should proceed
 * along the rope. Traversal terminates when the LBVHSentinel is reached for the rope.
 */
template<class QueryOpT, class OutputOpT, class TranslateOpT, class TransformOpT>
void LBVHTraverser::traverse(const LaunchParameters& params,
                             const LBVH& lbvh,
                             const QueryOpT& query,
                             const OutputOpT& out,
                             const TranslateOpT& images,
                             const TransformOpT& transform)
    {
    // don't traverse with empty lbvh
    if (lbvh.getN() == 0) return;

    // don't traverse with no query objects or images
    if (query.size() == 0 || images.size() == 0) return;

    // kernel uses int32 bitflags for the images, so limit to 32 images
    if (images.size() > 32)
        {
        throw std::runtime_error("A maximum of 32 image vectores are supported by LBVH traversers.");
        }

    checkParameter(params);

    // setup if this is not a replay
    if (!m_replay)
        setup(params, lbvh, transform);

    // compressed lbvh data
    LBVHCompressedData clbvh = data();

    // traversal data
    gpu::lbvh_traverse_ropes(out,
                             data(),
                             query,
                             images,
                             params.tunable,
                             params.stream);
    }

/*!
 * \param params Launch parameters for kernel execution, including tunable block size and stream.
 * \param lbvh LBVH to compress
 * \param transform Transformation operation for cached primitive indexes.
 *
 * \tparam TransformOpT The type of transformation operation.
 *
 * The nodes are compressed according to the scheme described previously. The storage
 * requirements are 16B / node (int4). The components of the int4 are:
 *
 *  - x: bits = 00lo.x[0-9]lo.y[0-9]lo.z[0-9]
 *  - y: bits = 00hi.x[0-9]hi.y[0-9]hi.z[0-9]
 *  - z: left child node (if >= 0) or primitive (if < 0)
 *  - w: rope
 *
 * The bits for the bounding box can be decompressed using:
 *      lo.x = ((unsigned int)node.x >> 20) & 0x3ffu;
 *      lo.y = ((unsigned int)node.x >> 10) & 0x3ffu;
 *      lo.z = ((unsigned int)node.x      ) & 0x3ffu;
 * which simply shifts and masks the low 10 bits. These integer bins should then be scaled by
 * the compressed bin size, which is stored internally.
 *
 * If node.z >= 0, then the current node is an internal node, and traversal should descend
 * to the child (node.z). If node.z < 0, the current node is actually a leaf node. In this case,
 * there is no left child. Instead, ~node.z gives a cached index for the intersected primitive.
 * The value that is stored in the cache is determined by \a transform. Sometimes this could just be
 * the original index of the primitive, but other times it might be useful to apply a mapping to the
 * index to save indirection when the index itself is not of interest.
 */
template<class TransformOpT>
void LBVHTraverser::compress(const LaunchParameters& params, const LBVH& lbvh, const TransformOpT& transform)
    {
    // check tuning parameter first
    checkParameter(params);

    // resize the internal data array
    const unsigned int num_data = lbvh.getNNodes();
    if (num_data > m_data.size())
        {
        shared_array<int4> tmp(num_data);
        m_data.swap(tmp);
        }

    // acquire current tree data for reading
    ConstLBVHData tree = lbvh.data();

    // set root and acquire compressed tree data for writing
    m_root = lbvh.getRoot();
    LBVHCompressedData ctree = data();

    // compress the data
    gpu::lbvh_compress_ropes(ctree,
                             transform,
                             tree,
                             lbvh.getNInternal(),
                             lbvh.getNNodes(),
                             params.tunable,
                             params.stream);
    }
} // end namespace neighbor

#endif // NEIGHBOR_LBVH_TRAVERSER_H_
